#!/bin/bash
readonly image=asx:latest
readonly hostname_=asx


# Running in a TTY?
test -t 1 && USE_TTY="-it"

# Exit with error on interrupt, or failure
set -e

# Variables
this_dir=$(cd -P $(dirname $0) ; pwd)

# Check podman is installed
if ! which podman >& /dev/null; then
   echo "Could not find 'podman'. You must install podman first"
   exit
fi

# If the container image does not yet exists, build it
if (($(podman images -q $image | wc -l) == 0)); then
   podman build -t $image $this_dir || { echo "Failed to build the container image"; exit; }
fi

if [[ $(realpath $PWD) == $(realpath ${this_dir})* ]]; then
   mountdir=$(realpath ${this_dir})
else
   mountdir=$(realpath ${this_dir}/..)
fi

base_opts="-u $(id -u $USER):$(getent group podman | cut -d: -f3) -v ${mountdir}:${mountdir}"
workdir="$(realpath $(pwd))"

[ -n "$SIM" ] && env_opt+="-e SIM=1"

# Name the runtime container uniquely
container_name="ASX_$(id -u)_$(date +%Y%m%d-%H%M%S)"

# Detect number of CPUs. Environment variable J can override the value. If no value given, then 1 is used
if [[ -v J ]]; then
   ((core_count=J)); ((core_count)) || let core_count=1
else
   core_count=$(nproc)
fi

# Force a build of the container image
if [[ "$1" == "build" ]]; then
   cd $this_dir
   podman build -t $image . || { echo "Failed to build the container image"; exit; }
   exit
fi

# Run make or start a shell
if [[ $1 == "make" ]]; then
   shift
   podman run ${USE_TTY} --rm --init --name $container_name $env_opt -h $hostname_ $base_opts -w $workdir $image make -j$core_count $@
else
   podman run ${USE_TTY} --rm --init --name $container_name $env_opt $xoptions -h $hostname_ $base_opts -w $workdir $image $@
fi
